<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Структури даних (англ."Data Structures") - My Docs</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Ласкаво просимо!</a>
                            </li>
                            <li class="navitem">
                                <a href="../INSTALL/" class="nav-link">INSTALL</a>
                            </li>
                            <li class="navitem">
                                <a href="../SUMMARY/" class="nav-link">Summary</a>
                            </li>
                            <li class="navitem">
                                <a href="../about/" class="nav-link">Додаток: про книгу</a>
                            </li>
                            <li class="navitem">
                                <a href="../about_python/" class="nav-link">Про мову програмування Python</a>
                            </li>
                            <li class="navitem">
                                <a href="../basics/" class="nav-link">Основи (англ."Basics")</a>
                            </li>
                            <li class="navitem">
                                <a href="../control_flow/" class="nav-link">Потік керування (англ."Control Flow")</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Структури даних (англ."Data Structures")</a>
                            </li>
                            <li class="navitem">
                                <a href="../dedication/" class="nav-link">Посвята</a>
                            </li>
                            <li class="navitem">
                                <a href="../exceptions/" class="nav-link">Винятки (англ."Exceptions")</a>
                            </li>
                            <li class="navitem">
                                <a href="../feedback/" class="nav-link">Зворотній зв'язок</a>
                            </li>
                            <li class="navitem">
                                <a href="../first_steps/" class="nav-link">Перші кроки</a>
                            </li>
                            <li class="navitem">
                                <a href="../floss/" class="nav-link">Додаток : FLOSS</a>
                            </li>
                            <li class="navitem">
                                <a href="../functions/" class="nav-link">Функції</a>
                            </li>
                            <li class="navitem">
                                <a href="../installation/" class="nav-link">Інсталяція</a>
                            </li>
                            <li class="navitem">
                                <a href="../io/" class="nav-link">Введення-виведення (англ."Input and Output ")</a>
                            </li>
                            <li class="navitem">
                                <a href="../modules/" class="nav-link">Модулі (англ."Modules")</a>
                            </li>
                            <li class="navitem">
                                <a href="../more/" class="nav-link">Більше</a>
                            </li>
                            <li class="navitem">
                                <a href="../oop/" class="nav-link">Об'єктно-орієнтоване програмування ( англ."Object Oriented Programming")</a>
                            </li>
                            <li class="navitem">
                                <a href="../op_exp/" class="nav-link">Оператори та вирази (англ. "Operators and Expressions")</a>
                            </li>
                            <li class="navitem">
                                <a href="../preface/" class="nav-link">Передмова</a>
                            </li>
                            <li class="navitem">
                                <a href="../problem_solving/" class="nav-link">Вирішення проблем (англ."Problem Solving")</a>
                            </li>
                            <li class="navitem">
                                <a href="../revision_history/" class="nav-link">Додаток: Урок історії</a>
                            </li>
                            <li class="navitem">
                                <a href="../stdlib/" class="nav-link">Стандартна бібліотека (англ."Standard Library")</a>
                            </li>
                            <li class="navitem">
                                <a href="../translation_howto/" class="nav-link">Додаток: Інструкція з перекладу</a>
                            </li>
                            <li class="navitem">
                                <a href="../translations/" class="nav-link">Переклади</a>
                            </li>
                            <li class="navitem">
                                <a href="../what_next/" class="nav-link">Що далі</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../control_flow/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../dedication/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#data-structures" class="nav-link">Структури даних (англ."Data Structures")</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#list" class="nav-link">Список (англ."List")</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#quick-introduction-to-objects-and-classes" class="nav-link">Короткий вступ до об’єктів і класів (англ."Quick Introduction To Objects And Classes")</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#tuple" class="nav-link">Кортеж (англ."Tuple")</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#set" class="nav-link">Множина (англ."Set")</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#references" class="nav-link">Посилання (англ."References")</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">Резюме</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="data-structures">Структури даних (англ."Data Structures")</h1>
<p>Структури даних — це, по суті, і є  <em>структури</em>, які можуть зберігати деякі <em>дані</em> разом. Іншими словами, вони використовуються для зберігання даних.</p>
<p>У Python є чотири вбудовані структури даних: <em>список (англ."list"), кортеж (англ."tuple"), словник (англ."dictionary") та множина (англ."set")</em>. Ми побачимо, як використовувати кожен із них і як вони полегшують нам життя.</p>
<h2 id="list">Список (англ."List")</h2>
<p>Список — це структура даних, яка містить упорядкований набір елементів, тобто зберігає <em>послідовність</em> елементів у списку (англ."<em>a sequence</em> of items in a list"). Це легко уявити, якщо згадати список покупок, в якому перераховується, що потрібно купити, з тим винятком, що у списку покупок кожен елемент зазвичай розміщується в окремому рядку, тоді як у Python вони розділяються комами.</p>
<p>Список елементів має бути укладений у квадратні дужки, щоб Python зрозумів, що ви вказуєте список. Створивши список, ви можете додавати, видаляти або шукати елементи у списку. Оскільки ми можемо додавати та видаляти елементи, ми говоримо, що список є <em>змінним</em> (англ."<em>mutable</em>") типом даних, тобто цей тип можна змінювати.</p>
<h2 id="quick-introduction-to-objects-and-classes">Короткий вступ до об’єктів і класів (англ."Quick Introduction To Objects And Classes")</h2>
<p>Хоч я і намагався досі відтягнути обговорення об'єктів і класів, на даному етапі все ж таки необхідне деяке пояснення, щоб ви краще зрозуміли ідею списків. Ми детально розглянемо цю тему у <a href="../oop/#oop">пізнішому розділі</a>.</p>
<p>Список є прикладом використання об'єктів і класів. Коли ми присвоюємо деякій змінній <code>i</code> значення, скажімо, ціле число <code>5</code>, ви можете сприймати це як створення <em>об’єкта</em> (тобто екземпляра) <code>i</code> <em>класу</em> (тобто типу) <code>int</code>. Насправді, ви можете прочитати <code>help(int)</code>, щоб зрозуміти це краще.</p>
<p>Клас також може мати <em>методи</em>, тобто функції, визначені для використання лише стосовно цього класу. Ви можете використовувати ці частини функціональності, лише якщо у вас є об’єкт цього класу. Наприклад, Python надає метод <code>append</code> для класу <code>список</code>, який дозволяє вам додавати елемент у кінець списку. Наприклад, <code>мій_список.append('якийсь елемент')</code> додасть цей рядок до списку <code>мій_список</code>. Зверніть увагу на використання нотації з крапками для доступу до методів об’єктів.</p>
<p>Клас також може мати <em>поля</em>, які є нічим іншим, як змінними, визначеними для використання лише стосовно цього класу. Ви можете використовувати ці змінні/імена, лише якщо у вас є об’єкт цього класу. Поля також доступні за допомогою нотації з крапками, наприклад, <code>мій_список.field</code>.</p>
<p>Приклад (збережіть як <code>ds_using_list.py</code>):</p>
<!--<pre><code class="lang-python">{% include "./programs/ds_using_list.py" %}</code></pre>

Output:

<pre><code>{% include "./programs/ds_using_list.txt" %}</code></pre>-->

<pre><code class="language-python"># Це мій список покупок 
список_покупок = ['яблуко', 'манго', 'морква', 'банан']

print('Я маю', len(список_покупок), 'товари для покупок.')

print('Товари для покупок:', end=' ')
for елементи in список_покупок:
    print(елементи, end=' ')

print('\nЯ також маю купити рис.')
список_покупок.append('рис')
print('Мій список покупок зараз', список_покупок)

print('Я відсортую свій список зараз')
список_покупок.sort()
print('Сортований список покупок є', список_покупок)

print('Перший товар, який я куплю, це', список_покупок[0])
старий_елемент = список_покупок[0]
del список_покупок[0]
print('Я купив', старий_елемент )
print('Мій список покупок зараз', список_покупок)
</code></pre>
<p>Висновок:</p>
<pre><code class="language-python">Я маю 4 товари для покупок.
Товари для покупок: яблуко манго морква банан 
Я також маю купити рис.
Мій список покупок зараз ['яблуко', 'манго', 'морква', 'банан', 'рис']
Я відсортую свій список зараз
Сортований список покупок є ['банан', 'манго', 'морква', 'рис', 'яблуко']
Перший товар, який я куплю, це банан
Я купив банан
Мій список покупок зараз ['манго', 'морква', 'рис', 'яблуко']
</code></pre>
<p><strong>Як це працює</strong></p>
<p>Змінна <code>список_покупок</code> - це список покупок для того, хто збирається на ринок. У <code>список_покупок</code> ми зберігаємо лише рядки назв предметів для покупки, але ви можете додавати <em>будь-які об’єкти</em> до списку, включаючи номери та навіть інші списки.</p>
<p>Ми також використали цикл for...in для ітерації по елементах списку. Наразі ви вже зрозуміли, що список також є послідовністю. Особливості  послідовностей буде обговорено у <a href="#sequence">пізнішому розділі</a>.</p>
<p>Зверніть увагу на використання параметра <code>end</code> у виклику функції <code>print</code>, який вказує, що ми хочемо закінчити рядок у висновку пробілом, замість звичайного розриву рядка.</p>
<p>Далі ми додаємо елемент до списку за допомогою методу <code>append</code>- методу об'єкта списку, як вже обговорювалося раніше. Потім ми перевіряємо, чи елемент справді додано до списку, друкуючи вміст списку за
допомогою передачі цього списку функції<code>print</code>, яка старанно друкує його.</p>
<p>Потім ми сортуємо список за допомогою методу <code>sort</code>об'єкта списку. Важливо розуміти, що цей метод впливає на сам список і не повертає змінений список - це відрізняється від того, як працюють рядки. Це те, що ми маємо на увазі, кажучи, що списки <em>змінні</em> ( англ."mutable"), а рядки <em>незмінні</em> ( англ."immutable").</p>
<p>Потім, коли ми закінчимо купувати товар на ринку, ми хочемо видалити його зі списку. Ми досягаємо цього за допомогою оператора del. Тут ми згадуємо, який елемент зі списку ми хочемо видалити, і оператор del видаляє його зі списку за нас. Ми вказуємо, що ми хочемо видалити перший елемент зі списку, і тому ми використовуємо <code>del список_покупок[0]</code> (пам’ятайте, що Python починає відлік з 0).</p>
<p>Якщо ви хочете дізнатися про всі методи, визначені об’єктом списку, подробиці дивіться у <code>help(list)</code>.</p>
<h2 id="tuple">Кортеж (англ."Tuple")</h2>
<p>Кортежі служать для зберігання кількох об'єктів разом. Вважайте їх подібними до списків, але без широкої функціональності, яку надає вам клас списку. Однією з головних особливостей кортежів є те, що вони <em>незмінні</em> (англ."<em>immutable</em>"),як і рядки, тобто ви не можете змінювати кортежі.</p>
<p>Кортежі позначаються визначенням елементів, розділених комами; за бажанням їх можна ще укласти в круглі дужки.</p>
<p>Кортежі зазвичай використовуються у випадках, коли оператор або визначена користувачем функція може безпечно припустити, що набір значень (тобто використаний кортеж значень) не зміниться.</p>
<p>Приклад: (збережіть як <code>ds_using_tuple.py</code>):</p>
<!--<pre><code class="lang-python">{% include "./programs/ds_using_tuple.py" %}</code></pre>

Output:

<pre><code>{% include "./programs/ds_using_tuple.txt" %}</code></pre>-->

<pre><code class="language-python"># Я рекомендую завжди використовувати круглі дужки
# позначати початок та кінец кортежу
# незважаючи на те, що дужки необов’язкові.
# Явний краще, ніж неявний.
зоопарк  = ('пітон', 'слон', 'пінгвін')
print('Кількість тварин у зоопарку становить', len(зоопарк))

новий_зоопарк = 'мавпа', 'верблюд', зоопарк # дужки не потрібні, але це гарна ідея
print('Кількість клітин у новому зоопарку становить', len(новий_зоопарк))
print('Усі тварини в новому зоопарку є', новий_зоопарк)
print('Тварини, привезені зі старого зоопарку є', новий_зоопарк[2])
print('Остання тварина, привезена зі старого зоопарку', новий_зоопаркo[2][2])
print('Кількість тварин у новому зоопарку становить',
      len(новий_зоопарк)-1+len(новий_зоопарк[2]))
</code></pre>
<p>Висновок :
```$ python ds_using_tuple.py
Кількість тварин у зоопарку становить 3
Кількість клітин у новому зоопарку становить 3
Усі тварини в новому зоопарку є ('мавпа', 'верблюд', ('пітон', 'слон', 'пінгвін'))
Тварини, привезені зі старого зоопарку є ('пітон', 'слон', 'пінгвін')
Остання тварина, привезена зі старого зоопарку пінгвін
Кількість тварин у новому зоопарку становить 5</p>
<pre><code>
**Як це працює**

Змінна `зоопарк` означає кортеж елементів. Ми бачимо, що функцію `len` можна використовувати для отримання довжини кортежу. Це також вказує на те, що кортеж також є [послідовністю](#sequence).

Зараз ми переводимо цих тварин у новий зоопарк, оскільки старий зоопарк закривається. Таким чином, кортеж `новий_зоопарк` містить деяких тварин, які вже там разом із тваринами, привезеними зі старого зоопарку. Повертаючись до реальності, зауважте, що кортеж у кортежі не втрачає своєї ідентичності.

Ми можемо отримати доступ до елементів у кортежі, вказавши позицію елемента в парі квадратних дужок, як ми робили для списків. Це називається оператором _індексування_ (англ.&quot;_indexing_&quot;). Ми отримуємо доступ до третього елемента в `новий_зоопарк`, вказуючи `новий_зоопарк[2]`, і отримуємо доступ до третього елемента в третьому елементі в кортежі `новий_зоопарк`, вказуючи `новий_зоопарк[2][2]`. Це досить просто, якщо ви зрозуміли ідіому.

&gt; **Кортеж із 0 або 1 елементом**
&gt;
&gt; Порожній кортеж створюється пустою парою круглих дужок, наприклад `myempty = ()`. Однак кортеж з одним елементом не такий простий. Його потрібно вказати за допомогою коми після першого (і єдиного) елемента, щоб Python міг розрізнити кортеж і пару круглих дужок, які оточують об’єкт у виразі. Таким чином, щоб отримати кортеж, що містить елемент 2, вам потрібно буде вказати  `singleton = (2 , )`.

&lt;!-- --&gt;

&gt; **Примітка для програмістів Perl**
&gt;
&gt; Список у списку не втрачає своєї ідентичності, тобто списки не розгортаються, як у Perl. Те саме стосується кортежу в кортежі, або кортежу в списку, або списку в кортежі тощо. Що стосується Python, це просто об’єкти, які зберігаються за допомогою іншого об’єкта, от і все.

## Словник (англ.&quot;Dictionary&quot;)

Словник схожий на адресну книгу, де ви можете знайти адресу або контактні дані особи, знаючи лише її/її ім’я; тобто ми пов’язуємо *ключі* (імена) із *значеннями* (інформацією). Зауважте, що ключ має бути унікальним, тому що ви не знаєте коректність наданої інформації, якщо у вас є дві людини з однаковими іменами.

Зауважте, що ви можете використовувати лише незмінні об’єкти (наприклад, рядки) для ключів словника, але ви можете використовувати як незмінні, так і змінні об’єкти для значень словника. По суті, це означає, що ви повинні використовувати лише прості об’єкти для ключів.

Пари ключ-значення вказуються в словнику за допомогою наступної нотації: `d = {key1 : value1, key2 : value2 }`. Зверніть увагу, що ключ і значення відокремлені двокрапкою, а самі пари відокремлені комами, і все це взято у пару фігурних дужок.

Пам’ятайте, що пари ключ-значення в словнику не впорядковані жодним чином. Якщо вам потрібен певний порядок, вам доведеться самостійно відсортувати словник, перш ніж використовувати його.

Словники, які ви використовуватимете, є екземплярами/об’єктами класу `dict`.

Приклад (збережіть як `ds_using_dict.py`):

&lt;!--&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;{% include &quot;./programs/ds_using_dict.py&quot; %}&lt;/code&gt;&lt;/pre&gt;

Output:

&lt;pre&gt;&lt;code&gt;{% include &quot;./programs/ds_using_dict.txt&quot; %}&lt;/code&gt;&lt;/pre&gt;--&gt;

```python
# &quot;ab&quot; є скороченням від 'a'ddress'b'ook(address book-адресна книга).

ab = {
    'Swaroop': 'swaroop@swaroopch.com',
    'Larry': 'larry@wall.org',
    'Matsumoto': 'matz@ruby-lang.org',
    'Spammer': 'spammer@hotmail.com'
}

print(&quot;Адрес Swaroop'а:&quot;, ab['Swaroop'])

# Видалення пари ключ-значення
del ab['Spammer']

print('\nВ адресній книзі {} контакта\n'.format(len(ab)))

for ім_я, адреса in ab.items():
    print('Контакт {} за адресою: {}'.format(ім_я, адреса))

# Додавання пари ключ-значення
ab['Guido'] = 'guido@python.org'

if 'Guido' in ab:
    print(&quot;\nАдрес Guido:&quot;, ab['Guido'])

</code></pre>
<p>Висновок:
```$ python3 using_dict.py
Адрес Swaroop'а: swaroop@swaroopch.com</p>
<p>В адресній книзі 3 контакта</p>
<p>Контакт Swaroop за адресою: swaroop@swaroopch.com
Контакт Larry за адресою: larry@wall.org
Контакт Matsumoto за адресою: matz@ruby-lang.org</p>
<p>Адрес Guido: guido@python.org</p>
<pre><code>**Як це працює**

Ми створюємо словник `ab`, використовуючи вже розглянуту нотацію. Потім ми отримуємо доступ до пар ключ-значення, вказуючи ключ за допомогою оператора індексування, як обговорювалося в контексті списків і кортежів. Зверніть увагу на простий синтаксис.

Ми можемо видалити пари ключ-значення за допомогою нашого старого друга - оператора `del`. Ми просто вказуємо ім'я словника та оператор індексування для ключа, який потрібно видалити, і передаємо його оператору del. Для цієї операції немає необхідності знати значення, яке відповідає ключу.

Далі ми звертаємося до всіх пар ключ-значення нашого словника ,використовуючи метод `items`, який повертає список кортежів, де кожен кортеж містить пару елементів — ключ та значення. Ми отримуємо цю пару та присвоюємо їй значення змінних `ім_я` та `адреса` відповідно до кожної з пар за допомогою циклу `for..in`, а потім друкуємо ці значення в блоці for.

Ми можемо додати нові пари ключ-значення, просто використовуючи оператор індексування для доступу до ключа та присвоення йому деякого значення, як ми зробили для Guido у наведеному вище випадку.

Ми можемо перевірити, чи існує пара ключ-значення, використовуючи оператор `in`.

Щоб переглянути список методів класу `dict`, перегляньте `help(dict)`.


&gt; **Ключові аргументи і словники** (англ.&quot;Keyword Arguments and Dictionaries&quot;) 
&gt;
&gt; Якщо ви використовували ключові аргументи у своїх функціях, ви вже використовували словники! Просто подумайте про це: ви вказали пару ключ-значення серед параметрів функції при її визначенні, а коли звертаєтесь до змінних усередині функції, то це, власне, звернення за ключом до словника (який у термінах розробників компіляторів називається _таблицею імен_ (англ.&quot; symbol table&quot;)).

## Послідовність (англ.&quot;Sequence&quot;)

Списки, кортежі та рядки є прикладами послідовностей, але що таке послідовності і що в них такого особливого?

Основними функціями є *перевірка приналежності* (тобто вирази `in` та `not in`) і *операції індексування*, які дозволяють нам напряму отримати певний елемент послідовності.

Три типи послідовностей, згадані вище - списки, кортежі та рядки, також мають операцію зрізу (англ. *slicing*), яка дозволяє нам отримати зріз послідовності, тобто ії фрагмент.

Приклад (зберегти як `ds_seq.py`):

&lt;!--&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;{% include &quot;./programs/ds_seq.py&quot; %}&lt;/code&gt;&lt;/pre&gt;

Output:

&lt;pre&gt;&lt;code&gt;{% include &quot;./programs/ds_seq.txt&quot; %}&lt;/code&gt;&lt;/pre&gt;--&gt;

```python
список_покупок = ['яблуко', 'манго', 'морква', 'банан']
ім_я = 'swaroop'

# Операція індексування
print('Елемент 0 є', список_покупок[0])
print('Елемент 1 є', список_покупок[1])
print('Елемент 2 є', список_покупок[2])
print('Елемент 3 є', список_покупок[3])
print('Елемент -1 є', список_покупок[-1])
print('Елемент -2 є', список_покупок[-2])
print('Символ 0 є', ім_я[0])

# Зріз зі списку 
print('Елемент з 1 до 3 є', список_покупок[1:3])
print('Елемент з 2 до кінця є', список_покупок[2:])
print('Елемент з 1 до -1 є', список_покупок[1:-1])
print('Елемент від початку до кінця є',список_покупок[:])

# Зріз з рядка 
print('Символи з 1 до 3 є', ім_я[1:3])
print('Символи з 2 до кінця є', ім_я[2:])
print('Символи з 1 до  -1 є', ім_я[1:-1])
print('Символи від початку до кінця є', ім_я[:])
</code></pre>
<p>Висновок
```$ python3 seq.py
Елемент 0 є яблуко
Елемент 1 є манго
Елемент 2 є морква
Елемент 3 є банан
Елемент -1 є банан
Елемент -2 є морква
Символ 0 є s
Елемент з 1 до 3 є ['манго', 'морква']
Елемент з 2 до кінця є ['морква', 'банан']
Елемент з 1 до -1 є ['манго', 'морква']
Елемент від початку до кінця є ['яблуко', 'манго', 'морква', 'банан']
Символи з 1 по 3 є wa
Символи з 2 до кінця є aroop
Символи з 1 до  -1 є waroo
Символи від початку до кінця є swaroop</p>
<pre><code>
**Як це працює**

Спочатку ми бачимо, як використовувати індекси для отримання окремих елементів послідовності. Це також називається операцією _приписування індексу_ (англ.&quot;subscription operation&quot;).

Коли ми вказуємо число у квадратних дужках після послідовності, як показано вище, Python витягує елемент, який відповідає зазначеній позиції в послідовності. Пам’ятайте, що Python починає рахувати числа з 0. Отже, ` список_покупокt[0]` витягує перший елемент, а` список_покупокt[3]` витягує  четвертий елемент у послідовності ` список_покупок`.

Індекс також може бути від’ємним числом. У цьому випадку позиція обчислюється з кінця послідовності. Таким чином, ` список_покупок[-1]` посилається на останній елемент у послідовності, а` список_покупок[-2]` витягує  передостанній елемент у послідовності.

Операція зрізу використовується вказуючи ім’я послідовності, за якою слідують необов’язкові два числа, розділені двокрапкою всередині квадратних дужок. Зауважте, що це дуже схоже на операцію індексування, яку ви використовували досі. Пам’ятайте, що цифри необов’язкові, а двокрапка – обов’язкова.

Перше число (перед двокрапкою) в операції зрізу вказує позицію, з якої починається зріз, а друге число (після двокрапки) вказує, де зріз має закінчитися. Якщо перше число не вказано, Python розпочне з початку послідовності. Якщо друге число пропущено, Python зупиниться в кінці послідовності. Зверніть увагу,що отриманий зріз буде починатися із зазначеної початкової позиції (англ.&quot;_starts_&quot;),а закінчуватися перед зазначеної кінцевої позицією (англ.&quot;_end_&quot;), тобто, початкова позиція буде включена у зріз, а кінцева – ні.

Таким чином, `список_покупок[1:3]` повертає зріз із послідовності, починаючи з позиції 1, включає позицію 2, але зупиняється на позиції 3, і тому повертає *зріз* з двох елементів. Так само ` список_покупок[:]` повертає копію всієї послідовності.

Також можна робити зріз використовуючи від’ємні числа. Числа зі знаком мінус використовуються для позицій з кінця послідовності. Наприклад, ` список_покупок[:-1]` поверне зріз послідовності, який виключає останній елемент послідовності, але містить усе інше.

Ви також можете надати третій аргумент для зрізу, який є _кроком_ для зрізу (за замовчуванням розмір кроку дорівнює 1):

```python
&gt;&gt;&gt; список_покупок= ['яблуко', 'манго', 'морква', 'банан']
&gt;&gt;&gt; список_покупок[::1]
['яблуко', 'манго', 'морква', 'банан']
&gt;&gt;&gt; список_покупок[::2]
['яблуко', 'морква']
&gt;&gt;&gt; список_покупок[::3]
['яблуко', 'банан']
&gt;&gt;&gt; список_покупок[::-1]
['банан', 'морква', 'манго', 'яблуко']
</code></pre>
<p>Зауважте, що коли крок дорівнює 2, ми отримуємо елементи з позиціями 0, 2,... Коли розмір кроку дорівнює 3, ми отримуємо елементи з позиціями 0, 3,... тощо.</p>
<p>Спробуйте різні комбінації параметрів зрізу, використовуючи інтерактивний інтерпретатор Python, тобто підказку prompt, щоб ви могли негайно побачити результати. Чудова річ у послідовностях полягає в тому, що ви можете отримати доступ до кортежів, списків і рядків однаково!</p>
<h2 id="set">Множина (англ."Set")</h2>
<p>Множини - це <em>невпорядковані</em> (англ."<em>unordered</em> ") набори простих об'єктів. Вони необхідні тоді, коли присутність об'єкта в наборі важливіша за порядок або те, скільки разів даний об'єкт там зустрічається.</p>
<p>Використовуючи множини, ви можете перевірити приналежність, визначати, 
чи є ця множина підмножиною іншої множини, знайти перетин між двома множинами тощо.</p>
<pre><code class="language-python">Скандинавія = set([&quot;Данія&quot;,&quot;Норвегія&quot;,&quot;Швеція&quot;])
print(&quot;3 країни Скандинавії:&quot;, Скандинавія)
print(&quot;Чи є Ісландія частиною Скандинавії?: &quot;, &quot;Ісландія&quot; in Скандинавія)
print(&quot;Нордичні країни також включають Ісландію та Фінляндію&quot;)
Нордичні_країни = Скандинавія.copy() 
Нордичні_країни.add(&quot;Ісландія&quot;)
Нордичні_країни.add(&quot;Фінляндія&quot;)
print(&quot;Нордичні країни&quot;, Нордичні_країни )
print(&quot;Чи Нордичні країни є супермножиною Скандинавії?&quot;, Нордичні_країни.issuperset(Скандинавія))
print(&quot;Чи є Скандинавія підмножиною нордичних країн?&quot;, Скандинавія.issubset(Нордичні_країни))
країни_сухопутного_кордону = Нордичні_країни.copy()
країни_сухопутного_кордону.remove(&quot;Ісландія&quot;)
print(&quot;Нордичні країни з сухопутними кордонами: &quot;, країни_сухопутного_кордону)
print(&quot;Перетин Скандинавії та Нордичних країн: &quot;, Скандинавія.intersection(Нордичні_країни))

</code></pre>
<p><strong>Як це працює</strong></p>
<p>Якщо ви пам’ятаєте базову математику теорії множин зі школи, то цей приклад досить зрозумілий. Але якщо ні, ви можете пошукати в Google «теорію множин» і «діаграму Венна», щоб краще зрозуміти, як ми використовуємо множини в Python.</p>
<h2 id="references">Посилання (англ."References")</h2>
<p>Коли ви створюєте об’єкт і присвоюєте його змінній, змінна лише <em>посилається</em> на об’єкт і не є цим об’єктом! Тобто ім’я змінної вказує на ту частину пам’яті комп’ютера, де зберігається об’єкт. Це називається <em>прив’язкою</em> (англ."<em>binding</em>") імені до об’єкта.</p>
<p>Загалом, вам не потрібно турбуватися про це, проте є деякий неочевидний ефект, про який потрібно пам'ятати:</p>
<p>Приклад (зберегти як <code>ds_reference.py</code>):</p>
<!--<pre><code class="lang-python">{% include "./programs/ds_reference.py" %}</code></pre>

Output:

<pre><code>{% include "./programs/ds_reference.txt" %}</code></pre>-->

<pre><code class="language-python">print('Просте присвоєння')
список_покупок = ['яблуко', 'манго', 'морква', 'банан']
# мій_список — це просто інша назва, що вказує на той самий об’єкт!
мій_список = список_покупок

# Я купив перший товар, тому видаляю його зі списку
del список_покупок[0]

print('список_покупок :', список_покупок)
print('мій_список :', мій_список)
# Зауважте, що друкуються і список_покупок,і мій_список
# з однаковим списком без пункта «яблука»
# вони вказують на той самий об'єкт

print('Копіювати, зробивши повний зріз')
# Зробіть копію, зробивши повний зріз
мій_список = список_покупок[:]
# Видалити перший елемент
del мій_список[0]

print('список_покупок :', список_покупок)
print('мій_список :', мій_список)
# Зверніть увагу, що тепер два списки різні

</code></pre>
<p>Висновок</p>
<p>```$ python3 reference.py
Просте присвоєння
список_покупок : ['манго', 'морква', 'банан']
мій_список : ['манго', 'морква', 'банан']
Копіювати, зробивши повний зріз
список_покупок : ['манго', 'морква', 'банан']
мій_список : ['морква', 'банан']</p>
<pre><code>
**Як це працює**

Більшість пояснень доступна в коментарях.

Пам’ятайте, що якщо ви хочете зробити копію списку або подібних типів послідовностей, або складних об’єктів (а не простих _об’єктів_, таких як цілі числа), тоді ви повинні використовувати операцію зріз, щоб зробити копію. Якщо ви просто присвоїте назву змінної іншій назві, обидві вони «посилатимуться» на той самий об’єкт, і це може спричинити проблеми, якщо ви не будете обережні.

&gt; **Примітка для програмістів Perl**
&gt;
&gt; Пам’ятайте, що оператор присвоєння для списків **не** створює копію. Ви повинні використовувати операцію зріз, щоб створити копію послідовності.

## Докладніше про рядки (англ.&quot;More About Strings&quot;)

Ми вже детально обговорювали рядки раніше. Що ще можна про них дізнатися? Ну, чи знаєте ви, що рядки також є об’єктами та мають методи, які роблять усе, від перевірки частини рядка до видалення пробілів? Фактично, ви вже використовували рядковий метод... метод `format`!

Усі рядки, які ви використовуєте в програмах, є об’єктами класу `str`. Деякі корисні методи цього класу демонструються в наступному прикладі. Щоб отримати повний список таких методів, перегляньте `help(str)`.

Приклад (зберегти як `ds_str_methods.py`):

&lt;!--&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;{% include &quot;./programs/ds_str_methods.py&quot; %}&lt;/code&gt;&lt;/pre&gt;

Output:

&lt;pre&gt;&lt;code&gt;{% include &quot;./programs/ds_str_methods.txt&quot; %}&lt;/code&gt;&lt;/pre&gt;--&gt;
```python
# Це рядковий об'єкт
ім_я = 'Swaroop'

if ім_я.startswith('Swa'):
    print('Так, рядок починається з &quot;Swa&quot;')

if 'a' in ім_я:
    print('Так, він містить рядок &quot;a&quot;')

if ім_я.find('war') != -1:
    print('Так, він містить рядок &quot;war&quot;')

delimiter = '_*_'
мій_лист = ['Данія', 'Норвегія', 'Швеція', 'Ісланді','Фінляндія' ]
print(delimiter.join(мій_лист))
</code></pre>
<p>Висновок
```$ python3 str_methods.py
Так, рядок починається з "Swa"
Так, він містить рядок "a"
Так, він містить рядок "war"
Данія_<em><em>Норвегія</em></em><em>Швеція</em><em><em>Ісланді</em></em>_Фінляндія</p>
<p>```</p>
<p><strong>Як це працює</strong></p>
<p>Тут бачимо відразу кілька методів рядків у дії. Метод <code>startswith</code> використовується, щоб дізнатися, чи починається рядок із заданого рядка. Оператор <code>in</code> використовується, щоб перевірити, чи є певний рядок частиною цього рядка.</p>
<p>Метод <code>find</code> використовується для визначення позиції даного підрядка в рядку; <code>find</code> повертає -1, якщо не вдалося знайти підрядок. Клас <code>str</code> також має чудовий метод для <code>об'єднання</code>(англ. "<code>join</code>") елементів послідовності з рядком, який діє як роздільник між кожним елементом послідовності, і повертає більший рядок, згенерований із цього.</p>
<h2 id="_1">Резюме</h2>
<p>Ми детально дослідили різноманітні вбудовані структури даних Python. Ці структури даних будуть необхідними для написання програм розумного розміру.</p>
<p>Тепер, коли ми маємо багато основ Python, ми далі побачимо, як розробити та написати реальну програму Python.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
