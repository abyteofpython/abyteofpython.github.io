<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Об'єктно-орієнтоване програмування ( англ."Object Oriented Programming") - My Docs</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">My Docs</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href=".." class="nav-link">Ласкаво просимо!</a>
                            </li>
                            <li class="navitem">
                                <a href="../INSTALL/" class="nav-link">INSTALL</a>
                            </li>
                            <li class="navitem">
                                <a href="../SUMMARY/" class="nav-link">Summary</a>
                            </li>
                            <li class="navitem">
                                <a href="../about/" class="nav-link">Додаток: про книгу</a>
                            </li>
                            <li class="navitem">
                                <a href="../about_python/" class="nav-link">Про мову програмування Python</a>
                            </li>
                            <li class="navitem">
                                <a href="../basics/" class="nav-link">Основи (англ."Basics")</a>
                            </li>
                            <li class="navitem">
                                <a href="../control_flow/" class="nav-link">Потік керування (англ."Control Flow")</a>
                            </li>
                            <li class="navitem">
                                <a href="../data_structures/" class="nav-link">Структури даних (англ."Data Structures")</a>
                            </li>
                            <li class="navitem">
                                <a href="../dedication/" class="nav-link">Посвята</a>
                            </li>
                            <li class="navitem">
                                <a href="../exceptions/" class="nav-link">Винятки (англ."Exceptions")</a>
                            </li>
                            <li class="navitem">
                                <a href="../feedback/" class="nav-link">Зворотній зв'язок</a>
                            </li>
                            <li class="navitem">
                                <a href="../first_steps/" class="nav-link">Перші кроки</a>
                            </li>
                            <li class="navitem">
                                <a href="../floss/" class="nav-link">Додаток : FLOSS</a>
                            </li>
                            <li class="navitem">
                                <a href="../functions/" class="nav-link">Функції</a>
                            </li>
                            <li class="navitem">
                                <a href="../installation/" class="nav-link">Інсталяція</a>
                            </li>
                            <li class="navitem">
                                <a href="../io/" class="nav-link">Введення-виведення (англ."Input and Output ")</a>
                            </li>
                            <li class="navitem">
                                <a href="../modules/" class="nav-link">Модулі (англ."Modules")</a>
                            </li>
                            <li class="navitem">
                                <a href="../more/" class="nav-link">Більше</a>
                            </li>
                            <li class="navitem active">
                                <a href="./" class="nav-link">Об'єктно-орієнтоване програмування ( англ."Object Oriented Programming")</a>
                            </li>
                            <li class="navitem">
                                <a href="../op_exp/" class="nav-link">Оператори та вирази (англ. "Operators and Expressions")</a>
                            </li>
                            <li class="navitem">
                                <a href="../preface/" class="nav-link">Передмова</a>
                            </li>
                            <li class="navitem">
                                <a href="../problem_solving/" class="nav-link">Вирішення проблем (англ."Problem Solving")</a>
                            </li>
                            <li class="navitem">
                                <a href="../revision_history/" class="nav-link">Додаток: Урок історії</a>
                            </li>
                            <li class="navitem">
                                <a href="../stdlib/" class="nav-link">Стандартна бібліотека (англ."Standard Library")</a>
                            </li>
                            <li class="navitem">
                                <a href="../translation_howto/" class="nav-link">Додаток: Інструкція з перекладу</a>
                            </li>
                            <li class="navitem">
                                <a href="../translations/" class="nav-link">Переклади</a>
                            </li>
                            <li class="navitem">
                                <a href="../what_next/" class="nav-link">Що далі</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../more/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../op_exp/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#-object-oriented-programming" class="nav-link">Об'єктно-орієнтоване програмування ( англ."Object Oriented Programming")</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#self" class="nav-link">self</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#classes" class="nav-link">Класи (англ."Classes")</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#inheritance" class="nav-link">Наслідування (англ."Inheritance")</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="-object-oriented-programming">Об'єктно-орієнтоване програмування ( англ."Object Oriented Programming")</h1>
<p>Досі наші програми складалися з функцій, тобто блоків операторів, які маніпулюють даними. Такий підхід до створення програм називається <em>процедурно-орієнтованим</em> програмуванням. Існує ще один спосіб організації вашої програми, який полягає в тому, щоб об’єднати дані та функціональність усередині якогось об'єкта. Це називається парадигмою <em>об'єктно-орієнтованого</em> програмування. У більшості випадків ви можете використовувати процедурне програмування, але коли пишете великі програми або маєте проблему, яка краще підходить для цього методу, ви можете використовувати методи об’єктно-орієнтованого програмування.</p>
<p>Класи та об'єкти є двома основними аспектами об'єктно-орієнтованого програмування. <strong>Клас</strong> (англ."<strong>class</strong>") створює новий  <em>тип</em> (англ."<em>type</em>"), тим часом як <strong>об’єкти</strong>(англ."<strong>objects</strong>") є <strong>екземплярами</strong> (англ."<strong>instances</strong>") класу.Аналогічно,коли ми говоримо про <code>змінні типи int</code>, це означає, що змінні, які зберігають цілочисельні значення, є екземплярами (об'єктами) класу <code>int</code>.</p>
<blockquote>
<p><strong>Примітка для програмістів статичної мови</strong></p>
<p>Зауважте, що навіть цілі числа розглядаються як об’єкти (класу <code>int</code>), на відміну від C++ і Java (до версії 1.5), де цілі числа є примітивами.</p>
<p>Перегляньте <code>help(int)</code> для отримання додаткової інформації про клас.</p>
<p>Програмісти C# і Java 1.5 знайдуть це схожим з концепцією <em>упаковки та распаковки</em>(англ." <em>boxing та unboxing</em>").</p>
</blockquote>
<p>Об’єкти можуть зберігати дані за допомогою звичайних змінних, які <em>належать</em> об’єкту. Змінні, які належать об’єкту або класу, називаються <strong>полями</strong> (англ."<strong>fields</strong>"). Об’єкти також можуть мати функціонал,тобто мати функції, які <em>належать</em> до класу.Такі функції називаються <strong>методами</strong> (англ."<strong>methods</strong>") класу. Ця термінологія важлива, оскільки вона допомагає нам розрізняти незалежні функції і змінні,і ті, що належать до класу чи об’єкта. У сукупності поля та методи можна назвати <strong>атрибутами</strong> (англ."<strong>attributess</strong>")цього класу. </p>
<p>Поля бувають двох типів - вони можуть належати кожному екземпляру/об'єкту класа або вони можуть належати лише самому класу. Вони називаються <strong>змінними екземпляра</strong> (англ."<strong>instance variables</strong>") і <strong>змінними класа</strong> (англ."<strong>class variables</strong>") відповідно. </p>
<p>Клас створюється за допомогою ключового слова <code>class</code>. Поля та методи класу записуються в блоці кода з відступом.</p>
<h2 id="self"><code>self</code></h2>
<p>Методи класу мають лише одну конкретну відмінність від звичайних функцій — вони повинні мати додаткове ім’я, яке має бути додано на початку списку параметрів.Однак ви <strong>не</strong> надаєте значення цьому параметру під час виклику методу, це надасть Python. Ця конкретна змінна посилається на <em>сам</em> об’єкт екземпляра класу, і за домовленістю їй дається ім’я <code>self</code>.</p>
<p>Незважаючи на те, що ви можете дати будь-яку назву для цього параметра, <em>наполегливо рекомендовано</em> використовувати назву <code>self</code> - будь-яка інша назва однозначно неприйнятна. Є багато переваг використання стандартної назви - будь-який читач вашої програми одразу впізнає її, і навіть спеціалізовані IDE (інтегровані середовища розробки) можуть допомогти вам, якщо ви використовуєте <code>self</code>.</p>
<blockquote>
<p><strong>Примітка для програмістів C++/Java/C#</strong></p>
<p><code>self</code> у Python еквівалентний вказівнику <code>this</code> у C++ і посиланню <code>this</code> у Java та C#.</p>
</blockquote>
<p>Вам, мабуть, цікаво, як Python присвоює значення для <code>self</code> і чому вам не потрібно давати йому значення. Приклад прояснить це. Скажімо, у вас є клас під назвою <code>MyClass</code> і екземпляр цього класу під назвою <code>myobject</code>. Коли ви викликаєте метод цього об’єкта як <code>myobject.method(arg1, arg2)</code>, Python автоматично перетворює його на <code>MyClass.method(myobject, arg1, arg2)</code> — це все, що стосується спеціального <code>self</code> .</p>
<p>Це також означає, що якщо у вас є метод, який не приймає аргументів, ви все одно повинні мати один аргумент – <code>self</code>.</p>
<h2 id="classes">Класи (англ."Classes")</h2>
<p>Найпростіший можливий клас показано в наступному прикладі (збережіть як <code>oop_simplestclass.py</code>).</p>
<!--<pre><code class="lang-python">{% include "./programs/oop_simplestclass.py" %}</code></pre>

Output:

<pre><code>{% include "./programs/oop_simplestclass.txt" %}</code></pre>-->

<pre><code class="language-python">class Person:
    pass  # Порожній блок

p = Person()
print(p)
</code></pre>
<p>Висновок:
```$ python oop_simplestclass.py
&lt;<strong>main</strong>.Person instance at 0x10171f518&gt;</p>
<pre><code>
**Як це працює**

Ми створюємо новий клас, використовуючи оператор `class` і назву класу. Далі йде блок рядків коду з відступом, які утворюють тіло класу. У цьому випадку ми маємо порожній блок, який позначається оператором `pass`.

Далі ми створюємо об’єкт/екземпляр цього класу, використовуючи ім’я класу, після якого йде пара круглих дужок. (Ми дізнаємося [докладніше про інстанціювання](#init) у наступному розділі). Для нашої перевірки ми підтверджуємо тип змінної, просто друкуючи її. Вивод на екран повідомляє нам, що ми маємо екземпляр класу `Person` в модулі `__main__`.

Зверніть увагу, що також друкується адреса пам’яті комп’ютера, де зберігається ваш об’єкт. Адреса матиме інше значення на вашому комп’ютері, оскільки Python може зберігати об’єкт у будь-якому місці.

## Методи

Ми вже обговорювали, що класи/об’єкти можуть мати методи,  що являють собою функції, за винятком додаткової змінної  `self`. Тепер ми побачимо приклад (збережіть як `oop_method.py`).

&lt;!--&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;{% include &quot;./programs/oop_method.py&quot; %}&lt;/code&gt;&lt;/pre&gt;

Output:

&lt;pre&gt;&lt;code&gt;{% include &quot;./programs/oop_method.txt&quot; %}&lt;/code&gt;&lt;/pre&gt;--&gt;

```python
class Person:
    def скажи_привіт(self):
        print('Привіт,ти хто?')

p = Person()
p.скажи_привіт()
# Попередні 2 рядки також можна записати як
# Person().скажи_привіт()
</code></pre>
<p>Висновок:
```$ python oop_method.py
Привіт,ти хто?</p>
<pre><code>
**Як це працює**

Тут ми бачимо `self` в дії. Зверніть увагу, що метод `скажи_привіт_` не приймає параметрів, але все ще має `self` у визначенні функції.

## Метод __init__ ( англ.&quot;The `__init__` method&quot;)

Існує багато методів, які мають особливе значення у класах Python. Зараз ми побачимо значення методу `__init__`.

Метод `__init__` запускається, як тільки об’єкт класу створюється (тобто реалізується). Цей метод корисний для будь-якої *ініціалізації* (тобто передачі початкових значень вашому об’єкту), яку ви хочете зробити з вашим об’єктом. Зверніть увагу на подвійне підкреслення як на початку, так і в кінці імені.

Приклад (зберегти як `oop_init.py`):

&lt;!--&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;{% include &quot;./programs/oop_init.py&quot; %}&lt;/code&gt;&lt;/pre&gt;

Output:

&lt;pre&gt;&lt;code&gt;{% include &quot;./programs/oop_init.txt&quot; %}&lt;/code&gt;&lt;/pre&gt;--&gt;
```python
class Person:
    def __init__(self, ім_я):
        self.ім_я = ім_я

    def скажи_привіт(self):
        print('Привіт,моє ім_я', self.ім_я)

p = Person('Swaroop')
p.скажи_привіт()
# Попередні 2 рядки також можна записати як
# Person().скажи_привіт()
</code></pre>
<p>Висновок:
```$ python oop_init.py
Привіт,моє ім_я Swaroop</p>
<pre><code>
**Як це працює**

Тут ми визначаємо метод `__init__` так, щоб він приймав параметр `ім_я` (разом із звичайним `self`). Тут ми просто створюємо нове поле, яке також називається `ім_я`. Зауважте, що це дві різні змінні, хоча обидві вони називаються «ім_я». Немає жодних проблем, оскільки нотація з крапкою `self.ім_я` означає, що існує щось під назвою «ім_я», яке є частиною об’єкта під назвою «self», а інше `ім_я` є локальною змінною. Оскільки ми чітко вказуємо, яке ім’я маємо на увазі, плутанини немає.

Створюючи новий екземпляр `p` класу `Person`, ми вказуємо ім'я класу, після якого- аргументи в дужках: p = Person('Swaroop').

Ми явно не викликаємо метод `__init__`.
У цьому полягає особлива значимість цього методу.

Тепер ми можемо використовувати поле `self.ім_я` у наших методах, що продемонстровано в методі `скажи_привіт`.

## Змінні класу та об’єкту (англ.&quot;Class And Object Variables&quot;) 

Ми вже обговорювали функціональну частину класів і об’єктів (тобто методів), тепер давайте дізнаємося про частину даних. Дані, тобто поля, є не чим іншим, як звичайними змінними, які _прив’язані_ (англ.&quot;_bound_&quot;) до **просторів імен** (англ.&quot;**namespaces**&quot;)  класів і об’єктів. Це означає, що ці імена дійсні лише в контексті цих класів та об’єктів. Ось чому їх називають _просторами імен_ (_name spaces_).

Існує два типи _полів_ - змінні класу та змінні об'єкта, які різняться залежно від того,_належить_ змінна класу чи об'єкту відповідно.

**Змінні класу** (англ.&quot;**Class variables**&quot;) є спільними – до них можуть отримати доступ усі екземпляри цього класу. Існує лише одна копія змінної класу, і коли будь-який об’єкт вносить зміни до змінної класу, цю зміну побачать усі інші екземпляри.

**Змінні об’єкту** (англ.&quot;**Object variables**&quot;) не є спільними, змінні об’єкту належать кожному окремому об’єкту/екземпляру класу. У цьому випадку кожен об’єкт має власну копію поля, тобто вони не є спільними та жодним чином не пов’язані з полем з тим самим ім’ям в іншому екземплярі. Приклад допоможе зрозуміти це (збережіть як `oop_objvar.py`):

&lt;!--&lt;pre&gt;&lt;code class=&quot;lang-python&quot;&gt;{% include &quot;./programs/oop_objvar.py&quot; %}&lt;/code&gt;&lt;/pre&gt;

Output:

&lt;pre&gt;&lt;code&gt;{% include &quot;./programs/oop_objvar.txt&quot; %}&lt;/code&gt;&lt;/pre&gt;--&gt;
```python
class Робот:
    &quot;&quot;&quot;Представляє робота з ім’ям.&quot;&quot;&quot;

    # Змінна класу,яка підраховує кількість роботів
    населення = 0

    def __init__(self, ім_я):
        &quot;&quot;&quot;Створення (initialization -ініціалізація) даних.&quot;&quot;&quot;
        self.ім_я = ім_я
        print(&quot;(Ініціалізація {})&quot;.format(self.ім_я))

        # При створенні цієї особи, робот 
        # додається до змінної 'населення'
        Робот.населення += 1

    def вмирати(self):
        &quot;&quot;&quot;Я вмираю.&quot;&quot;&quot;
        print(&quot;{} знищується&quot;.format(self.ім_я))

        Робот.населення -= 1

        if Робот.населення == 0:
            print(&quot;{} я був останній.&quot;.format(self.ім_я))
        else:
            print(&quot;Все ще є {:d} робочий робот.&quot;.format(
                Робот.населення))

    def скажи_привіт(self):
        &quot;&quot;&quot;Привітання від робота..

        Так, вони можуть це зробити.&quot;&quot;&quot;
        print(&quot;Вітаю, мої господарі називають мене  {}.&quot;.format(self.ім_я))

    @classmethod
    def скільки(cls):
        &quot;&quot;&quot;Друкує поточне населення.&quot;&quot;&quot;
        print(&quot;У нас є {:d} робот.&quot;.format(cls.населення))


droid1 = Робот(&quot;R2-D2&quot;)
droid1.скажи_привіт()
Робот.скільки()

droid2 = Робот(&quot;C-3PO&quot;)
droid2.скажи_привіт()
Робот.скільки()

print(&quot;\nРоботи можуть виконувати тут певну роботу.\n&quot;)

print(&quot;Роботи закінчили свою роботу. Тож давайте їх знищимо.&quot;)
droid1.вмирати()
droid2.вмирати()
Робот.скільки()

</code></pre>
<p>Висновок:
```$ python oop_objvar.py
(Створення R2-D2)
Вітаю, мої господарі називають мене  R2-D2.
У нас є 1 робот.
(Створення C-3PO)
Вітаю, мої господарі називають мене  C-3PO.
У нас є 2 робот.</p>
<p>Роботи можуть виконувати тут певну роботу.</p>
<p>Роботи закінчили свою роботу. Тож давайте їх знищимо.
R2-D2 знищується
Все ще є 1 робочий робот.
C-3PO знищується
C-3PO я був останній.
У нас є 0 робот.</p>
<pre><code>
**Як це працює**

Це довгий приклад, але він допомагає продемонструвати природу змінних класу та об’єкта. Тут `населення` належить до класу `Робот` і, отже, є змінною класу. Змінна `ім_я` належить об’єкту (їй присвоюється значення за допомогою `self`) і, отже, є змінною об’єкта.

Таким чином, ми звертаємося до змінної класу `населення`як `Робот.населення`, а не `self.населення`. До змінної ж об'єкта `ім_я` у всіх методи цього об'єкта ми звертаємося за допомогою позначення  `self.ім_я`. Запам'ятайте цю просту різницю між змінними класу та об'єкта. Також зауважте, що змінна об’єкта з тим же іменем, що й змінна класу, приховає змінну класу!

Замість `Робот.населення` ми також могли б використати `self.__class__.населення`, оскільки кожен об’єкт посилається на свій клас через атрибут `self.__class__`.

`скільки` насправді є методом, який належить до класу, а не до об’єкта. Це означає, що ми можемо визначити його як &quot;`classmethod`&quot; або &quot;`staticmethod`&quot; залежно від того, чи потрібно нам знати, у якому класі ми знаходимося. Оскільки ми посилаємося на змінну класу, давайте використаємо `classmethod`.

Ми позначили метод `скільки` як метод класу за допомогою [decorator](./more.md#decorator).

Декоратори можна уявити як ярлик для виклику функції-обгортки (англ.&quot;wrapper function&quot;) (тобто функції, яка «обгортається» навколо іншої функції, щоб вона могла робити щось до або після внутрішньої функції), тому застосування декоратора `@classmethod` є таким самим, як і функція виклику: 

```python
скільки = classmethod(скільки)
</code></pre>
<p>Зверніть увагу, що метод <code>__init__</code> використовується для ініціалізації екземпляра <code>Робот</code> з ім'ям. У цьому методі ми збільшуємо кількість <code>населення</code> на 1, оскільки ми додаємо ще одного робота. Також зауважте, що значення <code>self.ім_я</code>  для кожного об’єкта свої, що свідчить про природу змінних об’єкта.</p>
<p>Пам’ятайте, що ви повинні звертатися до змінних і методів того самого об’єкта, використовуючи тільки <em>self</em>. Це називається <em>посиланням на атрибут</em> (англ."attribute reference.").</p>
<p>У цій програмі ми також бачимо використання <em>рядків документації</em> (англ."<em>docstrings</em>") для класів, а також  для методів. Під час виконання ми можемо звертатись до рядка документації класу за допомогою <code>Робот.__doc__</code> ,а до рядка документації методу – за допомогою <code>Robot.скажи_привіт.__doc__</code></p>
<p>У методі <code>вмирати</code> ми просто зменшуємо кількість <code>Робот.населення</code> на 1.</p>
<p>Усі члени класу є відкритими. Один виняток: якщо ви використовуєте елементи даних з іменами, що використовують <em>префікс подвійного підкреслення</em>,(англ."<em>double underscore prefix</em> ") наприклад <code>__privatevar</code>, Python використовує спотворення імен (англ."name-mangling"), щоб ефективно зробити їх приватною змінною.</p>
<p>Таким чином, висновок полягає в тому, що будь-яка змінна, яка має використовуватися лише в межах класу чи об’єкта, повинна починатися з підкреслення, а всі інші імена є загальнодоступними та можуть використовуватися іншими класами/об’єктами. Пам’ятайте, що це лише домовленість, і Python її не вимагає (за винятком подвійного префікса підкреслення).</p>
<blockquote>
<p><strong>Примітка для програмістів C++/Java/C#</strong></p>
<p>Усі члени класу (включно з членами даних) є <em>загальнодоступними</em> ( англ."<em>public</em>"), а всі методи — <em>віртуальними</em> (англ."<em>virtual</em>") у Python.</p>
</blockquote>
<h2 id="inheritance">Наслідування (англ."Inheritance")</h2>
<p>Однією з головних переваг об’єктно-орієнтованого програмування є <strong>багаторазове використання</strong> (англ."<strong>reuse</strong>")одного і того ж коду,  і один із способів цього досягти - за допомогою механізму <strong>наслідування</strong>(англ.<strong>inheritance</strong>). Наслідування найкраще можна уявити у вигляді відношення між класами як <strong>тип та підтип</strong> (англ." <strong>type and subtype</strong>"). </p>
<p>Припустімо, ви хочете написати програму, яка повинна відстежувати вчителів і студентів у коледжі. Вони мають деякі спільні характеристики, такі як ім’я, вік та адреса. Вони також мають певні характеристики, такі як зарплата, курси та відпустки для вчителів, а також оцінки та гонорари для студентів.</p>
<p>Можна створити для них незалежні класи та працювати з ними, але тоді додавання будь-якої нової загальної характеристики вимагатиме додавання її до кожного з цих незалежних класів окремо.Це швидко стає громіздким.</p>
<p>Кращим способом було б створити загальний клас під назвою <code>УчастникШколи</code>, а потім зробити так, щоб класи викладача і студента  <em>успадкували</em> цей клас, тобто вони стануть підтипами цього типу (класу), і тоді ми зможемо додати певні характеристики до цих підтипів -типів.</p>
<p>Цей підхід має багато переваг. Якщо ми додаємо/змінюємо будь-яку функціональність в <code>УчастникШколи</code>, це також автоматично відображається в підтипах. Наприклад, ви можете додати нове поле ідентифікаційної картки як для вчителів, так і для студентів, просто додавши його до класу УчастникШколи. Однак зміни в підтипах не впливають на інші підтипи. Ще одна перевага полягає в тому, що ви можете звертатися до об’єкта «вчитель» або «студент» як до об’єкта «УчастникШколи», що може бути корисним у деяких ситуаціях, наприклад підрахунок кількості учасників школи. Це називається <strong>поліморфізмом</strong>(англ."<strong>polymorphism</strong>"), коли підтип можна підставити у місці, де очікується батьківський тип, тобто об'єкт вважається екземпляром батьківського класу.</p>
<p>Також зауважте, що ми повторно використовуємо код батьківського класу, і нам не потрібно повторювати його в різних класах, як нам довелося б, якби ми використовували незалежні класи.</p>
<p>Клас <code>УчастникШколи</code>у цій ситуації відомий як <strong>базовий клас</strong>(англ."<strong>base class</strong>") або <strong>суперклас</strong>(англ." <strong>superclass</strong>"). Класи «Вчитель» і «Студент» називаються  <strong>похідними класами</strong> (англ."<strong>derived classes</strong>") або <strong>підкласами</strong>(англ." <strong>subclasses</strong>").</p>
<p>Тепер ми побачимо цей приклад на англійській мові як програму (збережіть як <code>oop_subclass.py</code>):</p>
<!--<pre><code class="lang-python">{% include "./programs/oop_subclass.py" %}</code></pre>

Output:

<pre><code>{% include "./programs/oop_subclass.txt" %}</code></pre>-->

<pre><code class="language-python">class SchoolMember:
    '''Represents any school member.'''
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print('(Initialized SchoolMember: {})'.format(self.name))

    def tell(self):
        '''Tell my details.'''
        print('Name:&quot;{}&quot; Age:&quot;{}&quot;'.format(self.name, self.age), end=&quot; &quot;)


class Teacher(SchoolMember):
    '''Represents a teacher.'''
    def __init__(self, name, age, salary):
        SchoolMember.__init__(self, name, age)
        self.salary = salary
        print('(Initialized Teacher: {})'.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print('Salary: &quot;{:d}&quot;'.format(self.salary))


class Student(SchoolMember):
    '''Represents a student.'''
    def __init__(self, name, age, marks):
        SchoolMember.__init__(self, name, age)
        self.marks = marks
        print('(Initialized Student: {})'.format(self.name))

    def tell(self):
        SchoolMember.tell(self)
        print('Marks: &quot;{:d}&quot;'.format(self.marks))

t = Teacher('Mrs. Shrividya', 40, 30000)
s = Student('Swaroop', 25, 75)

# prints a blank line
print()

members = [t, s]
for member in members:
    # Works for both Teachers and Students
    member.tell()
</code></pre>
<p>Висновок:
```$ python oop_subclass.py
(Initialized SchoolMember: Mrs. Shrividya)
(Initialized Teacher: Mrs. Shrividya)
(Initialized SchoolMember: Swaroop)
(Initialized Student: Swaroop)</p>
<p>Name:"Mrs. Shrividya" Age:"40" Salary: "30000"
Name:"Swaroop" Age:"25" Marks: "75"</p>
<pre><code>
Приклад українською:
```python
class УчастникШколи:
    '''Представляє будь-якого участника школи.'''
    def __init__(self, ім_я, вік):
        self.ім_я = ім_я
        self.вік = вік
        print('(Створено УчастникШколи: {})'.format(self.ім_я))

    def повідомити(self):
        '''Повідомити деталі.'''
        print('Ім_я:&quot;{}&quot; Вік:&quot;{}&quot;'.format(self.ім_я, self.вік), end=&quot; &quot;)


class Викладач(УчастникШколи):
    '''Представляє викладача.'''
    def __init__(self, ім_я, вік, зарплата):
        УчастникШколи.__init__(self, ім_я, вік)
        self.зарплата = зарплата
        print('(Створено Викладач: {})'.format(self.ім_я))

    def повідомити(self):
        УчастникШколи.повідомити(self)
        print('зарплата: &quot;{:d}&quot;'.format(self.зарплата))


class Студент(УчастникШколи):
    '''Представляє студента.'''
    def __init__(self, ім_я, вік, оцінки):
        УчастникШколи.__init__(self, ім_я, вік)
        self.оцінки = оцінки
        print('(Створено студент: {})'.format(self.ім_я))

    def повідомити(self):
        УчастникШколи.повідомити(self)
        print('Оцінки: &quot;{:d}&quot;'.format(self.оцінки))

t = Викладач('Mrs. Shrividya', 40, 30000)
s = Студент('Swaroop', 25, 75)

# друкує порожній рядок
print()

учасники = [t, s]
for учасники in учасники:
    # Працює як для вчителів, так і для студентів
    учасники.повідомити()

</code></pre>
<p>Висновок:
```$ python oop_subclass.py
(Створено УчастникШколи: Mrs. Shrividya)
(Створено Викладач: Mrs. Shrividya)
(Створено УчастникШколи: Swaroop)
(Створено студент: Swaroop)</p>
<p>Ім_я:"Mrs. Shrividya" Вік:"40" зарплата: "30000"
Ім_я:"Swaroop" Вік:"25" Оцінки: "75"</p>
<pre><code>
**Як це працює**

Щоб використовувати наслідування,при визначенні класу ми вказуємо імена його базових класів у вигляді кортежу,який йде відразу за його назвою (наприклад,`class Викладач (УчастникШколи)`).  Далі ми спостерігаємо, що метод`__init__` базового класу явно викликається за допомогою змінної `self`, щоб ми могли ініціалізувати частину об'єкта, що відноситься до базового класу. Це дуже важливо пам’ятати,оскільки ми визначаємо метод  `__init__`  у підкласах  `Викладач`  та  `Студент`, Python не викликає автоматично конструктор базового класу `УчастникШколи`, ви повинні викликати його самостійно у явному вигляді.

Навпаки, якщо ми не визначили метод  `__init__` у підкласі, Python автоматично викличе конструктор базового класу.

Хоча ми могли б обробляти екземпляри `Викладач` або `Студент` так само, як екземпляр `УчастникШколи`, і отримати доступ до методу `повідомити` класа`УчастникШколи`, просто ввівши `Викладач.повідомити` або `Студент.повідомити`.Натомість ми визначаємо інший метод `повідомити` у кожному підкласі (використовуючи метод `повідомити`  в класі`УчастникШколи` для його частини), щоб пристосувати його для цього підкласу. Оскільки ми це зробили, написавши `Викладач.повідомити`, Python використовує метод `повідомити` для цього підкласу проти суперкласу. Однак, якби у нас не було методу `повідомити` у підкласі, Python використовував би метод `повідомити` у суперкласі. Python завжди спочатку починає шукати методи у фактичному типі підкласу, і якщо він нічого не знаходить, він починає шукати методи в базових класах підкласу, один за іншим у тому порядку, в якому вони вказані в кортежі (тут у нас є лише 1 базовий клас, але ви можете мати кілька базових класів) у визначенні класу.

Примітка щодо термінології: якщо в кортежі наслідування зазначено більше одного класу, це називається **множинним наслідуванням**
(англ.&quot;**multiple inheritance**&quot;).

Параметр `end` використовується у функції `print` у методі `повідомити()` суперкласу, щоб надрукувати рядок і дозволити наступному друку продовжуватись у тому самому рядку. Це трюк, щоб змусити `print` не друкувати символ `\n` (новий рядок) у кінці друку.



## Резюме

Зараз ми дослідили різні аспекти класів і об'єктів, а також різну термінологію, пов'язану з ними. Ми також побачили переваги та підводні камені об’єктно-орієнтованого програмування. Python дуже об’єктно-орієнтований, і ретельне розуміння цих концепцій дуже допоможе вам у довгостроковій перспективі.

Далі ми дізнаємося, як працювати з введенням/виведенням і як отримувати доступ до файлів у Python.




&lt;table&gt;
&lt;tr&gt;&lt;th&gt;процедурно-орієнтоване програмування&lt;/th&gt;&lt;th&gt;об'єктно-орієнтоване програмування&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt; 

The function manipulates the Data

&lt;/td&gt;&lt;td&gt; 

Data  is organised in Classes.A Class is a way og organising Data

&lt;/td&gt;&lt;/tr&gt; 

&lt;tr&gt;&lt;td colspan=2&gt;Example:we have to organize a school.The school has many students. Each student has a first name and last name.  Приклад: ми повинні організувати школу. У школі багато учнів. Кожен учень має ім’я та прізвище.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt; 

```python
Student_1_first_name=&quot;KLAUS&quot;
Student_1_last_name=&quot;WILSON&quot;
Student_2_first_name=&quot;MARTIN&quot;
Student_2_last_name=&quot;TAYLOR&quot;
print(Student_1_first_name,Student_1_last_name)
print(Student_2_first_name,Student_2_last_name)






</code></pre>
<p></td><td></p>
<pre><code class="language-python">class Student:
    def __init__(self, first_name, last_name):
        self.first_name=first_name
        self.last_name=last_name

data=[Student(&quot;KLAUS&quot;,&quot;WILSON&quot;),Student(&quot;MARTIN&quot;,&quot;TAYLOR&quot;)]

for s in data:
    print(s.first_name,s.last_name)


</code></pre>
<tr><td> 

how it works

</td><td> 

how it works
We define the Student "Objects". Each Student is an object.Each Student is an INSTANT OF THE "STUDENT" CLASS.Therefore, each Student has a "first_name" and a "last_name" field ()
як це працює
Ми визначаємо Студент як "Об'єкти" . Кожен Cтудент є об’єктом. Кожен Cтудент є екземпляром класа «СТУДЕНТ». Тому кожен студент має поле «ім’я» та «прізвище» ()
</td></tr>

<tr><td colspan=2>Would this (printingthe names of the students) like work with procedural programming? YES       
For example,Icould make a list of(FIRST NAME_LAST NAME) list (a list of lists)</td></tr>
<tr><td> 


<pre><code class="language-python">
data=[[&quot;KLAUS&quot;,&quot;WILSON&quot;],[&quot;MARTIN&quot;,&quot;TAYLOR&quot;]]
for student in data:
    print(student[0],student[1])


</code></pre>



</td><td>


<pre><code class="language-python">


</code></pre>

<tr><td> 

<tr><td colspan=2>So far there is no difference between procedural and object-oriented. Both print a list of student Names. The procedural variant is a bit shorter, but the OO variant is better to read: s.first_name is easier to understand than student[0]
</td></tr>
<tr><td> 
</td></tr>
</table>
 we define the student "object".Each student is an object.Each student is an INSTANCE of the "student" class.Therefore,each student has a "FIRST NAME"  and a "LAST NAME" field()class Student:
    def__init__(self,first_name,last_name):
        self.first_name=first_name
        self.last_name=last_name



Now we have defined the student class_we can now create some student objects(they are instances of the student class)

class Student:
    def__init__(self, first_name, last_name):
        self.first_name=first_name
        self.last_name=last_name
data=[Student("KLAUS","WILSON"),Student("MARTIN","TAYLOR")]

for s in data:
    print(s.first_name,s.last.name)</div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/jquery-3.6.0.min.js"></script>
        <script src="../js/bootstrap.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
